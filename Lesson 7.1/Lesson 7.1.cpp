// Задача №10: 
// Дано: n, min, max, otr.
// Заполняем массив(n) вещественными значениями по определенному принципу - есть отрезок числовой оси 
// и задаются границы отрезка: Х1(min) и Х2(max). 
// Нужно получить разбиение этого отрезка на n(otr) (вводится с клавиатуры) равных частей. 
// Нужно вычеслить значения точек на этом отрезке, расположенные на равных расстояниях друг от друга и записать их в массив.

#include <iostream>
#include <vector>
using namespace std;


int main()
{
	float min, max, step = 0;
	int n, i = 0, j = 0, otr, point; // n - количество элементов в начальном массиве.
	cout << "Input n in start_massiv: "; cin >> n; 
	cout << "Input diapason min: "; cin >> min;
	cout << "Input diapason max: "; cin >> max;
	cout << "Input kol-vo otrezkov: "; cin >> otr; // количество отрезков на прямой.
	vector<float> A(n); // Массив произвольной длины с числами лежащими в диапазоне (min ... max). 

// Шаг №1. Создать массив произвольной длинны с числами в заданном диапозоне. 
// Для этого нужно иметь динамически изменяющийся шаг, который зависит от начала и конца диапозона.               |(+)
// Шаг №2. Заполнить вещественными числами.                                                                       |(+)
	step = (max - min) / (n - 1); // Для того чтобы max былo включительно в массив
	cout << "Step = " << step << endl;
	cout << "Start massiv: " << endl;
	cout << "______________" << endl;
	A[i] = min;
	for (i; i < n; ++i)
	{
		A.push_back(i);
		if (A[i] > max) 
		{
			A[i] = max;
			cout << i << "(" << i + 1 << ")" << "--> ";
			cout << "[" << A[i] << "]" << " " << endl;
		}
		else 
		{
			cout << i << "(" << i + 1 << ")" << "--> ";
			cout << "[" << A[i] << "]" << " " << endl;
			A[i] = A[i] + step;
			A[i + 1] = A[i];
		}

	}

// Шаг №3. Массив с точками этих отрезков будет начинаться с точки начала отрезка (т.е. min).                       |(+)
// Последующие точки находим следующим образом: длину массива = конец - начало на k и получаем шаг.                 |(+)
// Каждая последующая точка равна будет предыдущая + шаг. И заканчивается массив точкой конца отрезка (т.е. max).   |(+)
	cout << "______________" << endl;
	cout << "Finish massiv: " << endl;
	float L = (max - min) / otr; // шаг (расстояние между двумя соседствующими точками) начало/конец отрезка
	cout << "Step_L = " << L << endl;
	point = otr + 1; // количество точек будет на одну больше,чем количество отрезков.
	vector<float> B(point); // Массив с точками.

	B[j] = min; // первое значение точки отрезка && начало прямой
	for (j; j < point; ++j)
	{
		B.push_back(j);
		cout << j << "(" << j + 1 << ")" << "--> ";
		cout << "[" << B[j] << "]" << " " << endl;
		B[j] = B[j] + L;
		B[j + 1] = B[j];
	}
}